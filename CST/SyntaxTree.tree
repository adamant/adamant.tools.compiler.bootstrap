◊namespace Adamant.Tools.Compiler.Bootstrap.CST;
◊walkers_namespace Adamant.Tools.Compiler.Bootstrap.CST.Walkers;
◊base 'ISyntax';
◊prefix I;
◊suffix Syntax;
◊list FixedList;
◊using System.Numerics;
◊using Adamant.Tools.Compiler.Bootstrap.Core;
◊using Adamant.Tools.Compiler.Bootstrap.Core.Promises;
◊using Adamant.Tools.Compiler.Bootstrap.Framework;
◊using Adamant.Tools.Compiler.Bootstrap.IntermediateLanguage;
◊using Adamant.Tools.Compiler.Bootstrap.Names;
◊using Adamant.Tools.Compiler.Bootstrap.Symbols;
◊using Adamant.Tools.Compiler.Bootstrap.Tokens;
◊using Adamant.Tools.Compiler.Bootstrap.Types;

'ISyntax' = Span:'TextSpan';
CompilationUnit = File:'CodeFile' ImplicitNamespaceName:'NamespaceName' UsingDirectives:UsingDirective* Declarations:NonMemberDeclaration* AllEntityDeclarations:EntityDeclaration* Diagnostics:'Diagnostic'*;
UsingDirective = Name:'NamespaceName';

// ---------- Special Parts
BodyOrBlock = Statements:Statement*;
ElseClause;
BlockOrResult: ElseClause;
Binding = IsMutableBinding:'bool' Symbol:'IPromise<BindingSymbol>';
LocalBinding: Binding;

// ---------- Declarations
Declaration: 'ISyntax', 'IHasContainingLexicalScope' = File:'CodeFile' Name:'Name'? NameSpan:'TextSpan' Symbol:'IPromise<Symbol>';
EntityDeclaration: Declaration = AccessModifier:'IAccessModifierToken'?;
InvocableDeclaration: EntityDeclaration = Parameters:ConstructorParameter* ReachabilityAnnotations:ReachabilityAnnotation* Symbol:'IPromise<InvocableSymbol>';
ConcreteInvocableDeclaration: InvocableDeclaration = Body;

// ---------- Non-Member Declarations
NonMemberDeclaration: Declaration = ContainingNamespaceName:'NamespaceName' Name:'Name';
// TODO if a compound namespace declaration was actually mutiple declarations, it would simplify other things
NamespaceDeclaration: NonMemberDeclaration = IsGlobalQualified:'bool' DeclaredNames:'NamespaceName' FullName:'NamespaceName' Symbol:'Promise<NamespaceOrPackageSymbol>' UsingDirectives:UsingDirective* Declarations:NonMemberDeclaration*;

// ---------- Non-Member Entity Declarations
NonMemberEntityDeclaration: EntityDeclaration, NonMemberDeclaration = Name:'Name';
ClassDeclaration: NonMemberEntityDeclaration = MutableModifier:'IMutableKeywordToken'? Name:'Name' Symbol:'Promise<ObjectTypeSymbol>' Members:MemberDeclaration* DefaultConstructorSymbol:'ConstructorSymbol'?;
FunctionDeclaration: NonMemberEntityDeclaration, ConcreteInvocableDeclaration = IsExternalFunction:'bool' Name:'Name' Parameters:NamedParameter* ReturnType:Type? ReachabilityAnnotations:ReachabilityAnnotation* Body Symbol:'Promise<FunctionSymbol>';

// ---------- Member Declarations
// Note: by declaring the DeclaringClass property type with quotes, it avoids the system assuming it must represent a child syntax node
MemberDeclaration: EntityDeclaration = DeclaringClass:'IClassDeclarationSyntax';
MethodDeclaration: MemberDeclaration, InvocableDeclaration = Name:'Name' SelfParameter Parameters:NamedParameter* ReturnType:Type? Symbol:'Promise<MethodSymbol>';
AbstractMethodDeclaration: MethodDeclaration = SelfParameter Parameters:NamedParameter* ReturnType:Type? ReachabilityAnnotations:ReachabilityAnnotation*;
ConcreteMethodDeclaration: MethodDeclaration, ConcreteInvocableDeclaration = SelfParameter Parameters:NamedParameter* ReturnType:Type? ReachabilityAnnotations:ReachabilityAnnotation* Body;
ConstructorDeclaration: MemberDeclaration, ConcreteInvocableDeclaration = ImplicitSelfParameter:SelfParameter Parameters:ConstructorParameter* ReachabilityAnnotations:ReachabilityAnnotation* Body Symbol:'Promise<ConstructorSymbol>';
FieldDeclaration: MemberDeclaration, Binding = Name:'Name' Symbol:'Promise<FieldSymbol>' Type;
AssociatedFunctionDeclaration: MemberDeclaration, ConcreteInvocableDeclaration = Name:'Name' Parameters:NamedParameter* ReturnType:Type? ReachabilityAnnotations:ReachabilityAnnotation* Body Symbol:'Promise<FunctionSymbol>';


// ---------- Parameters --------------
Parameter = Name:'Name'? DataType:'IPromise<DataType>' Unused:'bool';
/// A parameter that can be declared in a constructor
ConstructorParameter: Parameter;
/// A parameter that creates a binding, i.e. a named or self parameter
BindingParameter: Parameter, LocalBinding;
NamedParameter: Parameter, ConstructorParameter, BindingParameter = Name:'Name' DeclarationNumber:'Promise<int?>' Type Symbol:'Promise<VariableSymbol>' DefaultValue:Expression?;
SelfParameter: Parameter, BindingParameter = MutableSelf:'bool' Symbol:'Promise<SelfParameterSymbol>';
FieldParameter: Parameter, ConstructorParameter = ReferencedSymbol:'Promise<FieldSymbol?>' DefaultValue:Expression?;

// ---------- Annotations
ReachabilityAnnotation;
ReachableFromAnnotation: ReachabilityAnnotation = ReachableFrom:NameExpression*;
CanReachAnnotation: ReachabilityAnnotation = CanReach:NameExpression*;

// ---------- Function Parts
InvocableName = Name:'Name';
Argument;
Body: BodyOrBlock = Statements:BodyStatement*;


// ---------- Types
Type;
TypeName: Type, 'IHasContainingLexicalScope' = Name:'TypeName' ReferencedSymbol:'Promise<TypeSymbol?>';
OptionalType: Type = Referent:Type;
CapabilityType: Type = ReferentType:Type Capability:'ReferenceCapability';

// ---------- Statements
Statement;
ResultStatement: Statement, BlockOrResult;
BodyStatement: Statement;
VariableDeclarationStatement: BodyStatement, LocalBinding = NameSpan:'TextSpan' Name:'Name' DeclarationNumber:'Promise<int?>' Symbol:'Promise<VariableSymbol>' Type? InferMutableType:'bool';
ExpressionStatement: BodyStatement;

// ---------- Expressions
Expression;
AssignableExpression: Expression;
AssignmentExpression: Expression = Operator:'AssignmentOperator';
BinaryOperatorExpression: Expression = Operator:'BinaryOperator';
BlockExpression: Expression, BlockOrResult, BodyOrBlock = Statements:Statement*;
BoolLiteralExpression: LiteralExpression = Value:'bool';
BorrowExpression: Expression = ReferencedSymbol:'Promise<BindingSymbol?>';
BreakExpression: Expression;
// TODO in the CST, we don't know that this is a field access, it is just a qualified access (not even member because namespaces don't have members)
FieldAccessExpression: AssignableExpression = AccessOperator:'AccessOperator' Field:NameExpression ReferencedSymbol:'IPromise<FieldSymbol?>';
ForeachExpression: Expression, LocalBinding = VariableName:'Name' DeclarationNumber:'Promise<int?>' Symbol:'Promise<VariableSymbol>' Type? Block:BlockExpression;
FunctionInvocationExpression: InvocationExpression, 'IHasContainingLexicalScope' = Namespace:'NamespaceName' FunctionNameSyntax:InvocableName Arguments:Argument* ReferencedSymbol:'Promise<FunctionSymbol?>';
IfExpression: Expression, ElseClause = ThenBlock:BlockOrResult ElseClause?;
ImplicitConversionExpression: Expression = Expression DataType:'DataType';
ImplicitImmutabilityConversionExpression: ImplicitConversionExpression = Expression;
ImplicitNoneConversionExpression: ImplicitConversionExpression = Expression ConvertToType:'OptionalType';
ImplicitNumericConversionExpression: ImplicitConversionExpression = Expression ConvertToType:'NumericType';
ImplicitOptionalConversionExpression: ImplicitConversionExpression = Expression ConvertToType:'OptionalType';
IntegerLiteralExpression: LiteralExpression = Value:'BigInteger';
InvocationExpression: Expression = Name:'Name' Arguments:Argument*;
LiteralExpression: Expression;
LoopExpression: Expression = Block:BlockExpression;
// TODO in the CST, we don't know that this is a method invocation, it is just a qualified invocation (not even member because namespaces don't have members)
// TODO remove IHasContainingLexicalScope when not needed because of conversion to FunctionInvocationExpression
MethodInvocationExpression: InvocationExpression, 'IHasContainingLexicalScope' = MethodNameSyntax:InvocableName Arguments:Argument* ReferencedSymbol:'Promise<MethodSymbol?>';
MoveExpression: Expression = ReferencedSymbol:'Promise<BindingSymbol?>';
NameExpression: AssignableExpression, 'IHasContainingLexicalScope' = Name:'Name'? ReferencedSymbol:'Promise<BindingSymbol?>';
NewObjectExpression: Expression = Type:TypeName ConstructorName:InvocableName? Arguments:Argument* ReferencedSymbol:'Promise<ConstructorSymbol?>';
NextExpression: Expression;
NoneLiteralExpression: LiteralExpression;
ReturnExpression: Expression;
SelfExpression: Expression = IsImplicit:'bool' ReferencedSymbol:'Promise<SelfParameterSymbol?>';
ShareExpression: Expression = ReferencedSymbol:'Promise<BindingSymbol?>';
StringLiteralExpression: LiteralExpression = Value:'string';
UnaryOperatorExpression: Expression = Fixity:'UnaryOperatorFixity' Operator:'UnaryOperator';
UnsafeExpression: Expression;
WhileExpression: Expression = Block:BlockExpression;
