◊namespace Adamant.Tools.Compiler.Bootstrap.CST;
◊base 'ISyntax';
◊prefix I;
◊suffix Syntax;
◊list FixedList;
◊using System.Numerics;
◊using Adamant.Tools.Compiler.Bootstrap.Core;
◊using Adamant.Tools.Compiler.Bootstrap.Framework;
◊using Adamant.Tools.Compiler.Bootstrap.IntermediateLanguage;
◊using Adamant.Tools.Compiler.Bootstrap.Metadata;
◊using Adamant.Tools.Compiler.Bootstrap.Names;
◊using Adamant.Tools.Compiler.Bootstrap.Symbols;
◊using Adamant.Tools.Compiler.Bootstrap.Tokens;
◊using Adamant.Tools.Compiler.Bootstrap.Types;

'ISyntax' = Span:TextSpan;
CompilationUnit = CodeFile ImplicitNamespaceName:NamespaceName UsingDirectives:UsingDirective* Declarations:NonMemberDeclaration* AllEntityDeclarations:EntityDeclaration* Diagnostics:Diagnostic*;
UsingDirective = Name:NamespaceName;

// Function Parts
CallableName = Name:MaybeQualifiedName;
Argument;
Body: BodyOrBlock = Statements:BodyStatement*;

// Special Parts
BodyOrBlock = Statements:Statement*;
ElseClause;
BlockOrResult: ElseClause;

// Declarations
Declaration: 'ISyntax', IHasContainingLexicalScope = File:CodeFile NameSpan:TextSpan;
EntityDeclaration: Declaration = AccessModifier:IAccessModifierToken? Name? Symbol:IPromise<Symbol>;
CallableDeclaration: EntityDeclaration, IFunctionMetadata = ReachabilityAnnotations:ReachabilityAnnotation*;
ConcreteCallableDeclaration: CallableDeclaration = Body;

// Non-Member Declarations
NonMemberDeclaration: Declaration = ContainingNamespaceName:NamespaceName;
NamespaceDeclaration: NonMemberDeclaration, Declaration = IsGlobalQualified:bool DeclaredNames:NamespaceName FullName:NamespaceName Symbol:Promise<NamespaceOrPackageSymbol> UsingDirectives:UsingDirective* Declarations:NonMemberDeclaration*;

// Non-Member Entity Declarations
NonMemberEntityDeclaration: EntityDeclaration, NonMemberDeclaration = Name;
ClassDeclaration: NonMemberEntityDeclaration = MutableModifier:IMutableKeywordToken? Name Symbol:Promise<ObjectTypeSymbol> Members:MemberDeclaration*;
FunctionDeclaration: NonMemberEntityDeclaration, ConcreteCallableDeclaration = IsExternalFunction:bool Name Symbol:Promise<FunctionSymbol> ReturnType:Type? ReturnDataType:Promise<DataType>;
AssociatedFunctionDeclaration: MemberDeclaration, ConcreteCallableDeclaration = Name Symbol:Promise<FunctionSymbol> ReturnType:Type? ReturnDataType:Promise<DataType>;

// Member Declarations
MemberDeclaration: EntityDeclaration = DeclaringClass:ClassDeclaration;
MethodDeclaration: MemberDeclaration, CallableDeclaration = Name Symbol:Promise<MethodSymbol> SelfParameter ReturnType:Type? ReturnDataType:Promise<DataType>;
AbstractMethodDeclaration: MethodDeclaration;
ConcreteMethodDeclaration: MethodDeclaration, ConcreteCallableDeclaration;
ConstructorDeclaration: MemberDeclaration, ConcreteCallableDeclaration = Symbol:Promise<ConstructorSymbol> ImplicitSelfParameter:SelfParameter;
FieldDeclaration: MemberDeclaration = Name Symbol:Promise<FieldSymbol> Type;

// Parameters
Parameter: 'ISyntax', IBindingMetadata = Name? Symbol:IPromise<BindingSymbol> Unused:bool;
ConstructorParameter: Parameter = Name Symbol:Promise<VariableSymbol>;
NamedParameter: Parameter, ConstructorParameter = Type DefaultValue:Expression?;
SelfParameter: Parameter = MutableSelf:bool Symbol:Promise<SelfParameterSymbol>;
FieldParameter: Parameter, ConstructorParameter = DefaultValue:Expression?;

// Annotations
ReachabilityAnnotation;
ReachableFromAnnotation: ReachabilityAnnotation = ReachableFrom:NameExpression*;
CanReachAnnotation: ReachabilityAnnotation = CanReach:NameExpression*;

// Types
Type;
TypeName: Type, IHasContainingScope, IHasContainingLexicalScope = Name:'TypeName';
OptionalType: Type = Referent:Type;
CapabilityType: Type = ReferentType:Type Capability:ReferenceCapability;

// Statements
Statement;
ResultStatement: Statement, BlockOrResult;
BodyStatement: Statement;
VariableDeclarationStatement: BodyStatement, IBindingMetadata = NameSpan:TextSpan Name Symbol:Promise<VariableSymbol> TypeSyntax:Type? InferMutableType:bool;
ExpressionStatement: BodyStatement;

// Expressions
Expression;
AssignableExpression: Expression;
AssignmentExpression: Expression = Operator:AssignmentOperator;
BinaryOperatorExpression: Expression = Operator:BinaryOperator;
BlockExpression: Expression, BlockOrResult, BodyOrBlock;
BoolLiteralExpression: LiteralExpression = Value:bool;
BorrowExpression: Expression;
BreakExpression: Expression;
FieldAccessExpression: AssignableExpression = AccessOperator Field:NameExpression;
ForeachExpression: Expression = VariableName:Name Symbol:Promise<VariableSymbol> TypeSyntax:Type? Block:BlockExpression;
FunctionInvocationExpression: InvocationExpression = FunctionNameSyntax:CallableName;
IfExpression: Expression, ElseClause = ThenBlock:BlockOrResult ElseClause?;
ImplicitConversionExpression: Expression = Expression DataType;
ImplicitImmutabilityConversionExpression: ImplicitConversionExpression;
ImplicitNoneConversionExpression: ImplicitConversionExpression = ConvertToType:'OptionalType';
ImplicitNumericConversionExpression: ImplicitConversionExpression = ConvertToType:NumericType;
ImplicitOptionalConversionExpression: ImplicitConversionExpression = ConvertToType:'OptionalType';
IntegerLiteralExpression: LiteralExpression = Value:BigInteger;
InvocationExpression: Expression = FullName:MaybeQualifiedName Arguments:Argument*;
LiteralExpression: Expression;
LoopExpression: Expression = Block:BlockExpression;
MethodInvocationExpression: InvocationExpression = MethodNameSyntax:CallableName;
MoveExpression: Expression;
NameExpression: AssignableExpression, IHasContainingScope = Name:SimpleName;
NewObjectExpression: Expression = TypeSyntax:TypeName ConstructorName:CallableName? Arguments:Argument*;
NextExpression: Expression;
NoneLiteralExpression: LiteralExpression;
ReturnExpression: Expression;
SelfExpression: Expression, IHasContainingScope = IsImplicit:bool;
ShareExpression: Expression = SharedSymbol:IBindingMetadata;
StringLiteralExpression: LiteralExpression = Value:string;
UnaryOperatorExpression: Expression = Fixity:UnaryOperatorFixity Operator:UnaryOperator;
UnsafeExpression: Expression;
WhileExpression: Expression = Block:BlockExpression;
